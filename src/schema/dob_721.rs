// Generated by Molecule 0.7.5
#![allow(unused)]

use molecule::prelude::*;
#[derive(Clone)]
pub struct String(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for String {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for String {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for String {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for String {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        String::new_unchecked(v)
    }
}
impl String {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> StringReader<'r> {
        StringReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for String {
    type Builder = StringBuilder;
    const NAME: &'static str = "String";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        String(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StringReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StringReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct StringReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StringReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StringReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StringReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> StringReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for StringReader<'r> {
    type Entity = String;
    const NAME: &'static str = "StringReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StringReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StringBuilder(pub(crate) Vec<Byte>);
impl StringBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte) -> Option<Byte> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for StringBuilder {
    type Entity = String;
    const NAME: &'static str = "StringBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        String::new_unchecked(inner.into())
    }
}
pub struct StringIterator(String, usize, usize);
impl ::core::iter::Iterator for StringIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for StringIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for String {
    type Item = Byte;
    type IntoIter = StringIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        StringIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct StringVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StringVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StringVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StringVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for StringVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StringVec::new_unchecked(v)
    }
}
impl StringVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<String> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> String {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            String::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            String::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> StringVecReader<'r> {
        StringVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StringVec {
    type Builder = StringVecBuilder;
    const NAME: &'static str = "StringVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StringVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StringVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StringVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct StringVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StringVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StringVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StringVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> StringVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<StringReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> StringReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            StringReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            StringReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for StringVecReader<'r> {
    type Entity = StringVec;
    const NAME: &'static str = "StringVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StringVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            StringReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StringVecBuilder(pub(crate) Vec<String>);
impl StringVecBuilder {
    pub fn set(mut self, v: Vec<String>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: String) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = String>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: String) -> Option<String> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for StringVecBuilder {
    type Entity = StringVec;
    const NAME: &'static str = "StringVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StringVec::new_unchecked(inner.into())
    }
}
pub struct StringVecIterator(StringVec, usize, usize);
impl ::core::iter::Iterator for StringVecIterator {
    type Item = String;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for StringVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for StringVec {
    type Item = String;
    type IntoIter = StringVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        StringVecIterator(self, 0, len)
    }
}
impl<'r> StringVecReader<'r> {
    pub fn iter<'t>(&'t self) -> StringVecReaderIterator<'t, 'r> {
        StringVecReaderIterator(&self, 0, self.len())
    }
}
pub struct StringVecReaderIterator<'t, 'r>(&'t StringVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for StringVecReaderIterator<'t, 'r> {
    type Item = StringReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for StringVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Number(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Number {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Number {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Number {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Number {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Number::new_unchecked(v)
    }
}
impl Number {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> NumberReader<'r> {
        NumberReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Number {
    type Builder = NumberBuilder;
    const NAME: &'static str = "Number";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Number(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct NumberReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NumberReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NumberReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NumberReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> NumberReader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for NumberReader<'r> {
    type Entity = Number;
    const NAME: &'static str = "NumberReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NumberReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct NumberBuilder(pub(crate) [Byte; 8]);
impl ::core::fmt::Debug for NumberBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for NumberBuilder {
    fn default() -> Self {
        NumberBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl NumberBuilder {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn set(mut self, v: [Byte; 8]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
}
impl molecule::prelude::Builder for NumberBuilder {
    type Entity = Number;
    const NAME: &'static str = "NumberBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Number::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct NumberRange(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NumberRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NumberRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NumberRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for NumberRange {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NumberRange::new_unchecked(v)
    }
}
impl NumberRange {
    const DEFAULT_VALUE: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 8;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Number {
        Number::new_unchecked(self.0.slice(0..8))
    }
    pub fn nth1(&self) -> Number {
        Number::new_unchecked(self.0.slice(8..16))
    }
    pub fn as_reader<'r>(&'r self) -> NumberRangeReader<'r> {
        NumberRangeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NumberRange {
    type Builder = NumberRangeBuilder;
    const NAME: &'static str = "NumberRange";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NumberRange(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberRangeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberRangeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct NumberRangeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NumberRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NumberRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NumberRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl<'r> NumberRangeReader<'r> {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 8;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> NumberReader<'r> {
        NumberReader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn nth1(&self) -> NumberReader<'r> {
        NumberReader::new_unchecked(&self.as_slice()[8..16])
    }
}
impl<'r> molecule::prelude::Reader<'r> for NumberRangeReader<'r> {
    type Entity = NumberRange;
    const NAME: &'static str = "NumberRangeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NumberRangeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct NumberRangeBuilder(pub(crate) [Number; 2]);
impl ::core::fmt::Debug for NumberRangeBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for NumberRangeBuilder {
    fn default() -> Self {
        NumberRangeBuilder([Number::default(), Number::default()])
    }
}
impl NumberRangeBuilder {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 8;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Number; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Number) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Number) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for NumberRangeBuilder {
    type Entity = NumberRange;
    const NAME: &'static str = "NumberRangeBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NumberRange::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MutantRange(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MutantRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MutantRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MutantRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for MutantRange {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MutantRange::new_unchecked(v)
    }
}
impl MutantRange {
    const DEFAULT_VALUE: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 8;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Number {
        Number::new_unchecked(self.0.slice(0..8))
    }
    pub fn nth1(&self) -> Number {
        Number::new_unchecked(self.0.slice(8..16))
    }
    pub fn as_reader<'r>(&'r self) -> MutantRangeReader<'r> {
        MutantRangeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MutantRange {
    type Builder = MutantRangeBuilder;
    const NAME: &'static str = "MutantRange";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MutantRange(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MutantRangeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MutantRangeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct MutantRangeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MutantRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MutantRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MutantRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl<'r> MutantRangeReader<'r> {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 8;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> NumberReader<'r> {
        NumberReader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn nth1(&self) -> NumberReader<'r> {
        NumberReader::new_unchecked(&self.as_slice()[8..16])
    }
}
impl<'r> molecule::prelude::Reader<'r> for MutantRangeReader<'r> {
    type Entity = MutantRange;
    const NAME: &'static str = "MutantRangeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MutantRangeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct MutantRangeBuilder(pub(crate) [Number; 2]);
impl ::core::fmt::Debug for MutantRangeBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for MutantRangeBuilder {
    fn default() -> Self {
        MutantRangeBuilder([Number::default(), Number::default()])
    }
}
impl MutantRangeBuilder {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 8;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Number; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Number) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Number) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for MutantRangeBuilder {
    type Entity = MutantRange;
    const NAME: &'static str = "MutantRangeBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MutantRange::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct NumberVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NumberVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NumberVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NumberVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for NumberVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NumberVec::new_unchecked(v)
    }
}
impl NumberVec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Number> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Number {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Number::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> NumberVecReader<'r> {
        NumberVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NumberVec {
    type Builder = NumberVecBuilder;
    const NAME: &'static str = "NumberVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NumberVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct NumberVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NumberVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NumberVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NumberVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> NumberVecReader<'r> {
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<NumberReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> NumberReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        NumberReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for NumberVecReader<'r> {
    type Entity = NumberVec;
    const NAME: &'static str = "NumberVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NumberVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct NumberVecBuilder(pub(crate) Vec<Number>);
impl NumberVecBuilder {
    pub const ITEM_SIZE: usize = 8;
    pub fn set(mut self, v: Vec<Number>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Number) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Number>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Number) -> Option<Number> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for NumberVecBuilder {
    type Entity = NumberVec;
    const NAME: &'static str = "NumberVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NumberVec::new_unchecked(inner.into())
    }
}
pub struct NumberVecIterator(NumberVec, usize, usize);
impl ::core::iter::Iterator for NumberVecIterator {
    type Item = Number;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for NumberVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for NumberVec {
    type Item = Number;
    type IntoIter = NumberVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        NumberVecIterator(self, 0, len)
    }
}
impl<'r> NumberVecReader<'r> {
    pub fn iter<'t>(&'t self) -> NumberVecReaderIterator<'t, 'r> {
        NumberVecReaderIterator(&self, 0, self.len())
    }
}
pub struct NumberVecReaderIterator<'t, 'r>(&'t NumberVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for NumberVecReaderIterator<'t, 'r> {
    type Item = NumberReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for NumberVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct MutantVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MutantVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MutantVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MutantVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for MutantVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MutantVec::new_unchecked(v)
    }
}
impl MutantVec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Number> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Number {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Number::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> MutantVecReader<'r> {
        MutantVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MutantVec {
    type Builder = MutantVecBuilder;
    const NAME: &'static str = "MutantVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MutantVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MutantVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MutantVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct MutantVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MutantVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MutantVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MutantVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> MutantVecReader<'r> {
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<NumberReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> NumberReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        NumberReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for MutantVecReader<'r> {
    type Entity = MutantVec;
    const NAME: &'static str = "MutantVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MutantVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct MutantVecBuilder(pub(crate) Vec<Number>);
impl MutantVecBuilder {
    pub const ITEM_SIZE: usize = 8;
    pub fn set(mut self, v: Vec<Number>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Number) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Number>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Number) -> Option<Number> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for MutantVecBuilder {
    type Entity = MutantVec;
    const NAME: &'static str = "MutantVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MutantVec::new_unchecked(inner.into())
    }
}
pub struct MutantVecIterator(MutantVec, usize, usize);
impl ::core::iter::Iterator for MutantVecIterator {
    type Item = Number;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for MutantVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for MutantVec {
    type Item = Number;
    type IntoIter = MutantVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        MutantVecIterator(self, 0, len)
    }
}
impl<'r> MutantVecReader<'r> {
    pub fn iter<'t>(&'t self) -> MutantVecReaderIterator<'t, 'r> {
        MutantVecReaderIterator(&self, 0, self.len())
    }
}
pub struct MutantVecReaderIterator<'t, 'r>(&'t MutantVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for MutantVecReaderIterator<'t, 'r> {
    type Item = NumberReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for MutantVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct FloatVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FloatVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FloatVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FloatVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "numerator_vec", self.numerator_vec())?;
        write!(f, ", {}: {}", "denominator", self.denominator())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for FloatVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        FloatVec::new_unchecked(v)
    }
}
impl FloatVec {
    const DEFAULT_VALUE: [u8; 24] = [
        24, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn numerator_vec(&self) -> NumberVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        NumberVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn denominator(&self) -> Number {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Number::new_unchecked(self.0.slice(start..end))
        } else {
            Number::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> FloatVecReader<'r> {
        FloatVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FloatVec {
    type Builder = FloatVecBuilder;
    const NAME: &'static str = "FloatVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FloatVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FloatVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FloatVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .numerator_vec(self.numerator_vec())
            .denominator(self.denominator())
    }
}
#[derive(Clone, Copy)]
pub struct FloatVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FloatVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FloatVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FloatVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "numerator_vec", self.numerator_vec())?;
        write!(f, ", {}: {}", "denominator", self.denominator())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> FloatVecReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn numerator_vec(&self) -> NumberVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        NumberVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn denominator(&self) -> NumberReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            NumberReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            NumberReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FloatVecReader<'r> {
    type Entity = FloatVec;
    const NAME: &'static str = "FloatVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FloatVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        NumberVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        NumberReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct FloatVecBuilder {
    pub(crate) numerator_vec: NumberVec,
    pub(crate) denominator: Number,
}
impl FloatVecBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn numerator_vec(mut self, v: NumberVec) -> Self {
        self.numerator_vec = v;
        self
    }
    pub fn denominator(mut self, v: Number) -> Self {
        self.denominator = v;
        self
    }
}
impl molecule::prelude::Builder for FloatVecBuilder {
    type Entity = FloatVec;
    const NAME: &'static str = "FloatVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.numerator_vec.as_slice().len()
            + self.denominator.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.numerator_vec.as_slice().len();
        offsets.push(total_size);
        total_size += self.denominator.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.numerator_vec.as_slice())?;
        writer.write_all(self.denominator.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FloatVec::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct FloatRange(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FloatRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FloatRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FloatRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "numerator_range", self.numerator_range())?;
        write!(f, ", {}: {}", "denominator", self.denominator())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for FloatRange {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        FloatRange::new_unchecked(v)
    }
}
impl FloatRange {
    const DEFAULT_VALUE: [u8; 36] = [
        36, 0, 0, 0, 12, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn numerator_range(&self) -> NumberRange {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        NumberRange::new_unchecked(self.0.slice(start..end))
    }
    pub fn denominator(&self) -> Number {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Number::new_unchecked(self.0.slice(start..end))
        } else {
            Number::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> FloatRangeReader<'r> {
        FloatRangeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FloatRange {
    type Builder = FloatRangeBuilder;
    const NAME: &'static str = "FloatRange";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FloatRange(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FloatRangeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FloatRangeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .numerator_range(self.numerator_range())
            .denominator(self.denominator())
    }
}
#[derive(Clone, Copy)]
pub struct FloatRangeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FloatRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FloatRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FloatRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "numerator_range", self.numerator_range())?;
        write!(f, ", {}: {}", "denominator", self.denominator())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> FloatRangeReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn numerator_range(&self) -> NumberRangeReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        NumberRangeReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn denominator(&self) -> NumberReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            NumberReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            NumberReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FloatRangeReader<'r> {
    type Entity = FloatRange;
    const NAME: &'static str = "FloatRangeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FloatRangeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        NumberRangeReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        NumberReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct FloatRangeBuilder {
    pub(crate) numerator_range: NumberRange,
    pub(crate) denominator: Number,
}
impl FloatRangeBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn numerator_range(mut self, v: NumberRange) -> Self {
        self.numerator_range = v;
        self
    }
    pub fn denominator(mut self, v: Number) -> Self {
        self.denominator = v;
        self
    }
}
impl molecule::prelude::Builder for FloatRangeBuilder {
    type Entity = FloatRange;
    const NAME: &'static str = "FloatRangeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.numerator_range.as_slice().len()
            + self.denominator.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.numerator_range.as_slice().len();
        offsets.push(total_size);
        total_size += self.denominator.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.numerator_range.as_slice())?;
        writer.write_all(self.denominator.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FloatRange::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TraitType(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TraitType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TraitType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TraitType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for TraitType {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TraitType::new_unchecked(v)
    }
}
impl TraitType {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 4, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 7;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> TraitTypeUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => StringVec::new_unchecked(inner).into(),
            1 => NumberVec::new_unchecked(inner).into(),
            2 => FloatVec::new_unchecked(inner).into(),
            3 => MutantVec::new_unchecked(inner).into(),
            4 => NumberRange::new_unchecked(inner).into(),
            5 => FloatRange::new_unchecked(inner).into(),
            6 => MutantRange::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitTypeReader<'r> {
        TraitTypeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TraitType {
    type Builder = TraitTypeBuilder;
    const NAME: &'static str = "TraitType";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TraitType(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitTypeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitTypeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct TraitTypeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TraitTypeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TraitTypeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TraitTypeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> TraitTypeReader<'r> {
    pub const ITEMS_COUNT: usize = 7;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> TraitTypeUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => StringVecReader::new_unchecked(inner).into(),
            1 => NumberVecReader::new_unchecked(inner).into(),
            2 => FloatVecReader::new_unchecked(inner).into(),
            3 => MutantVecReader::new_unchecked(inner).into(),
            4 => NumberRangeReader::new_unchecked(inner).into(),
            5 => FloatRangeReader::new_unchecked(inner).into(),
            6 => MutantRangeReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TraitTypeReader<'r> {
    type Entity = TraitType;
    const NAME: &'static str = "TraitTypeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TraitTypeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => StringVecReader::verify(inner_slice, compatible),
            1 => NumberVecReader::verify(inner_slice, compatible),
            2 => FloatVecReader::verify(inner_slice, compatible),
            3 => MutantVecReader::verify(inner_slice, compatible),
            4 => NumberRangeReader::verify(inner_slice, compatible),
            5 => FloatRangeReader::verify(inner_slice, compatible),
            6 => MutantRangeReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TraitTypeBuilder(pub(crate) TraitTypeUnion);
impl TraitTypeBuilder {
    pub const ITEMS_COUNT: usize = 7;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<TraitTypeUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for TraitTypeBuilder {
    type Entity = TraitType;
    const NAME: &'static str = "TraitTypeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TraitType::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum TraitTypeUnion {
    StringVec(StringVec),
    NumberVec(NumberVec),
    FloatVec(FloatVec),
    MutantVec(MutantVec),
    NumberRange(NumberRange),
    FloatRange(FloatRange),
    MutantRange(MutantRange),
}
#[derive(Debug, Clone, Copy)]
pub enum TraitTypeUnionReader<'r> {
    StringVec(StringVecReader<'r>),
    NumberVec(NumberVecReader<'r>),
    FloatVec(FloatVecReader<'r>),
    MutantVec(MutantVecReader<'r>),
    NumberRange(NumberRangeReader<'r>),
    FloatRange(FloatRangeReader<'r>),
    MutantRange(MutantRangeReader<'r>),
}
impl ::core::default::Default for TraitTypeUnion {
    fn default() -> Self {
        TraitTypeUnion::StringVec(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for TraitTypeUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TraitTypeUnion::StringVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, StringVec::NAME, item)
            }
            TraitTypeUnion::NumberVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberVec::NAME, item)
            }
            TraitTypeUnion::FloatVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, FloatVec::NAME, item)
            }
            TraitTypeUnion::MutantVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MutantVec::NAME, item)
            }
            TraitTypeUnion::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            TraitTypeUnion::FloatRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, FloatRange::NAME, item)
            }
            TraitTypeUnion::MutantRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MutantRange::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for TraitTypeUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TraitTypeUnionReader::StringVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, StringVec::NAME, item)
            }
            TraitTypeUnionReader::NumberVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberVec::NAME, item)
            }
            TraitTypeUnionReader::FloatVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, FloatVec::NAME, item)
            }
            TraitTypeUnionReader::MutantVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MutantVec::NAME, item)
            }
            TraitTypeUnionReader::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            TraitTypeUnionReader::FloatRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, FloatRange::NAME, item)
            }
            TraitTypeUnionReader::MutantRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MutantRange::NAME, item)
            }
        }
    }
}
impl TraitTypeUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TraitTypeUnion::StringVec(ref item) => write!(f, "{}", item),
            TraitTypeUnion::NumberVec(ref item) => write!(f, "{}", item),
            TraitTypeUnion::FloatVec(ref item) => write!(f, "{}", item),
            TraitTypeUnion::MutantVec(ref item) => write!(f, "{}", item),
            TraitTypeUnion::NumberRange(ref item) => write!(f, "{}", item),
            TraitTypeUnion::FloatRange(ref item) => write!(f, "{}", item),
            TraitTypeUnion::MutantRange(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> TraitTypeUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TraitTypeUnionReader::StringVec(ref item) => write!(f, "{}", item),
            TraitTypeUnionReader::NumberVec(ref item) => write!(f, "{}", item),
            TraitTypeUnionReader::FloatVec(ref item) => write!(f, "{}", item),
            TraitTypeUnionReader::MutantVec(ref item) => write!(f, "{}", item),
            TraitTypeUnionReader::NumberRange(ref item) => write!(f, "{}", item),
            TraitTypeUnionReader::FloatRange(ref item) => write!(f, "{}", item),
            TraitTypeUnionReader::MutantRange(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<StringVec> for TraitTypeUnion {
    fn from(item: StringVec) -> Self {
        TraitTypeUnion::StringVec(item)
    }
}
impl ::core::convert::From<NumberVec> for TraitTypeUnion {
    fn from(item: NumberVec) -> Self {
        TraitTypeUnion::NumberVec(item)
    }
}
impl ::core::convert::From<FloatVec> for TraitTypeUnion {
    fn from(item: FloatVec) -> Self {
        TraitTypeUnion::FloatVec(item)
    }
}
impl ::core::convert::From<MutantVec> for TraitTypeUnion {
    fn from(item: MutantVec) -> Self {
        TraitTypeUnion::MutantVec(item)
    }
}
impl ::core::convert::From<NumberRange> for TraitTypeUnion {
    fn from(item: NumberRange) -> Self {
        TraitTypeUnion::NumberRange(item)
    }
}
impl ::core::convert::From<FloatRange> for TraitTypeUnion {
    fn from(item: FloatRange) -> Self {
        TraitTypeUnion::FloatRange(item)
    }
}
impl ::core::convert::From<MutantRange> for TraitTypeUnion {
    fn from(item: MutantRange) -> Self {
        TraitTypeUnion::MutantRange(item)
    }
}
impl<'r> ::core::convert::From<StringVecReader<'r>> for TraitTypeUnionReader<'r> {
    fn from(item: StringVecReader<'r>) -> Self {
        TraitTypeUnionReader::StringVec(item)
    }
}
impl<'r> ::core::convert::From<NumberVecReader<'r>> for TraitTypeUnionReader<'r> {
    fn from(item: NumberVecReader<'r>) -> Self {
        TraitTypeUnionReader::NumberVec(item)
    }
}
impl<'r> ::core::convert::From<FloatVecReader<'r>> for TraitTypeUnionReader<'r> {
    fn from(item: FloatVecReader<'r>) -> Self {
        TraitTypeUnionReader::FloatVec(item)
    }
}
impl<'r> ::core::convert::From<MutantVecReader<'r>> for TraitTypeUnionReader<'r> {
    fn from(item: MutantVecReader<'r>) -> Self {
        TraitTypeUnionReader::MutantVec(item)
    }
}
impl<'r> ::core::convert::From<NumberRangeReader<'r>> for TraitTypeUnionReader<'r> {
    fn from(item: NumberRangeReader<'r>) -> Self {
        TraitTypeUnionReader::NumberRange(item)
    }
}
impl<'r> ::core::convert::From<FloatRangeReader<'r>> for TraitTypeUnionReader<'r> {
    fn from(item: FloatRangeReader<'r>) -> Self {
        TraitTypeUnionReader::FloatRange(item)
    }
}
impl<'r> ::core::convert::From<MutantRangeReader<'r>> for TraitTypeUnionReader<'r> {
    fn from(item: MutantRangeReader<'r>) -> Self {
        TraitTypeUnionReader::MutantRange(item)
    }
}
impl TraitTypeUnion {
    pub const NAME: &'static str = "TraitTypeUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            TraitTypeUnion::StringVec(item) => item.as_bytes(),
            TraitTypeUnion::NumberVec(item) => item.as_bytes(),
            TraitTypeUnion::FloatVec(item) => item.as_bytes(),
            TraitTypeUnion::MutantVec(item) => item.as_bytes(),
            TraitTypeUnion::NumberRange(item) => item.as_bytes(),
            TraitTypeUnion::FloatRange(item) => item.as_bytes(),
            TraitTypeUnion::MutantRange(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            TraitTypeUnion::StringVec(item) => item.as_slice(),
            TraitTypeUnion::NumberVec(item) => item.as_slice(),
            TraitTypeUnion::FloatVec(item) => item.as_slice(),
            TraitTypeUnion::MutantVec(item) => item.as_slice(),
            TraitTypeUnion::NumberRange(item) => item.as_slice(),
            TraitTypeUnion::FloatRange(item) => item.as_slice(),
            TraitTypeUnion::MutantRange(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            TraitTypeUnion::StringVec(_) => 0,
            TraitTypeUnion::NumberVec(_) => 1,
            TraitTypeUnion::FloatVec(_) => 2,
            TraitTypeUnion::MutantVec(_) => 3,
            TraitTypeUnion::NumberRange(_) => 4,
            TraitTypeUnion::FloatRange(_) => 5,
            TraitTypeUnion::MutantRange(_) => 6,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            TraitTypeUnion::StringVec(_) => "StringVec",
            TraitTypeUnion::NumberVec(_) => "NumberVec",
            TraitTypeUnion::FloatVec(_) => "FloatVec",
            TraitTypeUnion::MutantVec(_) => "MutantVec",
            TraitTypeUnion::NumberRange(_) => "NumberRange",
            TraitTypeUnion::FloatRange(_) => "FloatRange",
            TraitTypeUnion::MutantRange(_) => "MutantRange",
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitTypeUnionReader<'r> {
        match self {
            TraitTypeUnion::StringVec(item) => item.as_reader().into(),
            TraitTypeUnion::NumberVec(item) => item.as_reader().into(),
            TraitTypeUnion::FloatVec(item) => item.as_reader().into(),
            TraitTypeUnion::MutantVec(item) => item.as_reader().into(),
            TraitTypeUnion::NumberRange(item) => item.as_reader().into(),
            TraitTypeUnion::FloatRange(item) => item.as_reader().into(),
            TraitTypeUnion::MutantRange(item) => item.as_reader().into(),
        }
    }
}
impl<'r> TraitTypeUnionReader<'r> {
    pub const NAME: &'r str = "TraitTypeUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            TraitTypeUnionReader::StringVec(item) => item.as_slice(),
            TraitTypeUnionReader::NumberVec(item) => item.as_slice(),
            TraitTypeUnionReader::FloatVec(item) => item.as_slice(),
            TraitTypeUnionReader::MutantVec(item) => item.as_slice(),
            TraitTypeUnionReader::NumberRange(item) => item.as_slice(),
            TraitTypeUnionReader::FloatRange(item) => item.as_slice(),
            TraitTypeUnionReader::MutantRange(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            TraitTypeUnionReader::StringVec(_) => 0,
            TraitTypeUnionReader::NumberVec(_) => 1,
            TraitTypeUnionReader::FloatVec(_) => 2,
            TraitTypeUnionReader::MutantVec(_) => 3,
            TraitTypeUnionReader::NumberRange(_) => 4,
            TraitTypeUnionReader::FloatRange(_) => 5,
            TraitTypeUnionReader::MutantRange(_) => 6,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            TraitTypeUnionReader::StringVec(_) => "StringVec",
            TraitTypeUnionReader::NumberVec(_) => "NumberVec",
            TraitTypeUnionReader::FloatVec(_) => "FloatVec",
            TraitTypeUnionReader::MutantVec(_) => "MutantVec",
            TraitTypeUnionReader::NumberRange(_) => "NumberRange",
            TraitTypeUnionReader::FloatRange(_) => "FloatRange",
            TraitTypeUnionReader::MutantRange(_) => "MutantRange",
        }
    }
}
#[derive(Clone)]
pub struct TraitTypeVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TraitTypeVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TraitTypeVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TraitTypeVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for TraitTypeVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TraitTypeVec::new_unchecked(v)
    }
}
impl TraitTypeVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<TraitType> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> TraitType {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            TraitType::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            TraitType::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitTypeVecReader<'r> {
        TraitTypeVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TraitTypeVec {
    type Builder = TraitTypeVecBuilder;
    const NAME: &'static str = "TraitTypeVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TraitTypeVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitTypeVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitTypeVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct TraitTypeVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TraitTypeVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TraitTypeVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TraitTypeVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> TraitTypeVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<TraitTypeReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> TraitTypeReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            TraitTypeReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            TraitTypeReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TraitTypeVecReader<'r> {
    type Entity = TraitTypeVec;
    const NAME: &'static str = "TraitTypeVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TraitTypeVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            TraitTypeReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TraitTypeVecBuilder(pub(crate) Vec<TraitType>);
impl TraitTypeVecBuilder {
    pub fn set(mut self, v: Vec<TraitType>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: TraitType) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = TraitType>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: TraitType) -> Option<TraitType> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for TraitTypeVecBuilder {
    type Entity = TraitTypeVec;
    const NAME: &'static str = "TraitTypeVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TraitTypeVec::new_unchecked(inner.into())
    }
}
pub struct TraitTypeVecIterator(TraitTypeVec, usize, usize);
impl ::core::iter::Iterator for TraitTypeVecIterator {
    type Item = TraitType;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for TraitTypeVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for TraitTypeVec {
    type Item = TraitType;
    type IntoIter = TraitTypeVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        TraitTypeVecIterator(self, 0, len)
    }
}
impl<'r> TraitTypeVecReader<'r> {
    pub fn iter<'t>(&'t self) -> TraitTypeVecReaderIterator<'t, 'r> {
        TraitTypeVecReaderIterator(&self, 0, self.len())
    }
}
pub struct TraitTypeVecReaderIterator<'t, 'r>(&'t TraitTypeVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for TraitTypeVecReaderIterator<'t, 'r> {
    type Item = TraitTypeReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for TraitTypeVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct TraitTypeVecOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TraitTypeVecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TraitTypeVecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TraitTypeVecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for TraitTypeVecOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TraitTypeVecOpt::new_unchecked(v)
    }
}
impl TraitTypeVecOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<TraitTypeVec> {
        if self.is_none() {
            None
        } else {
            Some(TraitTypeVec::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitTypeVecOptReader<'r> {
        TraitTypeVecOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TraitTypeVecOpt {
    type Builder = TraitTypeVecOptBuilder;
    const NAME: &'static str = "TraitTypeVecOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TraitTypeVecOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitTypeVecOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitTypeVecOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct TraitTypeVecOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TraitTypeVecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TraitTypeVecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TraitTypeVecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> TraitTypeVecOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<TraitTypeVecReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(TraitTypeVecReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TraitTypeVecOptReader<'r> {
    type Entity = TraitTypeVecOpt;
    const NAME: &'static str = "TraitTypeVecOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TraitTypeVecOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            TraitTypeVecReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TraitTypeVecOptBuilder(pub(crate) Option<TraitTypeVec>);
impl TraitTypeVecOptBuilder {
    pub fn set(mut self, v: Option<TraitTypeVec>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for TraitTypeVecOptBuilder {
    type Entity = TraitTypeVecOpt;
    const NAME: &'static str = "TraitTypeVecOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TraitTypeVecOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TraitSchema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TraitSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TraitSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TraitSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "byte_length", self.byte_length())?;
        write!(f, ", {}: {}", "traits_pool", self.traits_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TraitSchema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TraitSchema::new_unchecked(v)
    }
}
impl TraitSchema {
    const DEFAULT_VALUE: [u8; 13] = [13, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn byte_length(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn traits_pool(&self) -> TraitTypeVecOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TraitTypeVecOpt::new_unchecked(self.0.slice(start..end))
        } else {
            TraitTypeVecOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitSchemaReader<'r> {
        TraitSchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TraitSchema {
    type Builder = TraitSchemaBuilder;
    const NAME: &'static str = "TraitSchema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TraitSchema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitSchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitSchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .byte_length(self.byte_length())
            .traits_pool(self.traits_pool())
    }
}
#[derive(Clone, Copy)]
pub struct TraitSchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TraitSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TraitSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TraitSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "byte_length", self.byte_length())?;
        write!(f, ", {}: {}", "traits_pool", self.traits_pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TraitSchemaReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn byte_length(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn traits_pool(&self) -> TraitTypeVecOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TraitTypeVecOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TraitTypeVecOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TraitSchemaReader<'r> {
    type Entity = TraitSchema;
    const NAME: &'static str = "TraitSchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TraitSchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TraitTypeVecOptReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TraitSchemaBuilder {
    pub(crate) byte_length: Byte,
    pub(crate) traits_pool: TraitTypeVecOpt,
}
impl TraitSchemaBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn byte_length(mut self, v: Byte) -> Self {
        self.byte_length = v;
        self
    }
    pub fn traits_pool(mut self, v: TraitTypeVecOpt) -> Self {
        self.traits_pool = v;
        self
    }
}
impl molecule::prelude::Builder for TraitSchemaBuilder {
    type Entity = TraitSchema;
    const NAME: &'static str = "TraitSchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.byte_length.as_slice().len()
            + self.traits_pool.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.byte_length.as_slice().len();
        offsets.push(total_size);
        total_size += self.traits_pool.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.byte_length.as_slice())?;
        writer.write_all(self.traits_pool.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TraitSchema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TraitSchemaVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TraitSchemaVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TraitSchemaVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TraitSchemaVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for TraitSchemaVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TraitSchemaVec::new_unchecked(v)
    }
}
impl TraitSchemaVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<TraitSchema> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> TraitSchema {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            TraitSchema::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            TraitSchema::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitSchemaVecReader<'r> {
        TraitSchemaVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TraitSchemaVec {
    type Builder = TraitSchemaVecBuilder;
    const NAME: &'static str = "TraitSchemaVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TraitSchemaVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitSchemaVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitSchemaVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct TraitSchemaVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TraitSchemaVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TraitSchemaVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TraitSchemaVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> TraitSchemaVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<TraitSchemaReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> TraitSchemaReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            TraitSchemaReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            TraitSchemaReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TraitSchemaVecReader<'r> {
    type Entity = TraitSchemaVec;
    const NAME: &'static str = "TraitSchemaVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TraitSchemaVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            TraitSchemaReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TraitSchemaVecBuilder(pub(crate) Vec<TraitSchema>);
impl TraitSchemaVecBuilder {
    pub fn set(mut self, v: Vec<TraitSchema>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: TraitSchema) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = TraitSchema>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: TraitSchema) -> Option<TraitSchema> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for TraitSchemaVecBuilder {
    type Entity = TraitSchemaVec;
    const NAME: &'static str = "TraitSchemaVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TraitSchemaVec::new_unchecked(inner.into())
    }
}
pub struct TraitSchemaVecIterator(TraitSchemaVec, usize, usize);
impl ::core::iter::Iterator for TraitSchemaVecIterator {
    type Item = TraitSchema;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for TraitSchemaVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for TraitSchemaVec {
    type Item = TraitSchema;
    type IntoIter = TraitSchemaVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        TraitSchemaVecIterator(self, 0, len)
    }
}
impl<'r> TraitSchemaVecReader<'r> {
    pub fn iter<'t>(&'t self) -> TraitSchemaVecReaderIterator<'t, 'r> {
        TraitSchemaVecReaderIterator(&self, 0, self.len())
    }
}
pub struct TraitSchemaVecReaderIterator<'t, 'r>(&'t TraitSchemaVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for TraitSchemaVecReaderIterator<'t, 'r> {
    type Item = TraitSchemaReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for TraitSchemaVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Trait(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Trait {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Trait {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Trait {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "traits", self.traits())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Trait {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Trait::new_unchecked(v)
    }
}
impl Trait {
    const DEFAULT_VALUE: [u8; 20] = [
        20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> String {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        String::new_unchecked(self.0.slice(start..end))
    }
    pub fn traits(&self) -> TraitSchemaVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TraitSchemaVec::new_unchecked(self.0.slice(start..end))
        } else {
            TraitSchemaVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitReader<'r> {
        TraitReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Trait {
    type Builder = TraitBuilder;
    const NAME: &'static str = "Trait";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Trait(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().name(self.name()).traits(self.traits())
    }
}
#[derive(Clone, Copy)]
pub struct TraitReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TraitReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TraitReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TraitReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "traits", self.traits())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TraitReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> StringReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        StringReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn traits(&self) -> TraitSchemaVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TraitSchemaVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TraitSchemaVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TraitReader<'r> {
    type Entity = Trait;
    const NAME: &'static str = "TraitReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TraitReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        StringReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TraitSchemaVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TraitBuilder {
    pub(crate) name: String,
    pub(crate) traits: TraitSchemaVec,
}
impl TraitBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn name(mut self, v: String) -> Self {
        self.name = v;
        self
    }
    pub fn traits(mut self, v: TraitSchemaVec) -> Self {
        self.traits = v;
        self
    }
}
impl molecule::prelude::Builder for TraitBuilder {
    type Entity = Trait;
    const NAME: &'static str = "TraitBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.name.as_slice().len()
            + self.traits.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.traits.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.traits.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Trait::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TraitsBase(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TraitsBase {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TraitsBase {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TraitsBase {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for TraitsBase {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TraitsBase::new_unchecked(v)
    }
}
impl TraitsBase {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Trait> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Trait {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Trait::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Trait::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitsBaseReader<'r> {
        TraitsBaseReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TraitsBase {
    type Builder = TraitsBaseBuilder;
    const NAME: &'static str = "TraitsBase";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TraitsBase(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitsBaseReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitsBaseReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct TraitsBaseReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TraitsBaseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TraitsBaseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TraitsBaseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> TraitsBaseReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<TraitReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> TraitReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            TraitReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            TraitReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TraitsBaseReader<'r> {
    type Entity = TraitsBase;
    const NAME: &'static str = "TraitsBaseReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TraitsBaseReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            TraitReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TraitsBaseBuilder(pub(crate) Vec<Trait>);
impl TraitsBaseBuilder {
    pub fn set(mut self, v: Vec<Trait>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Trait) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Trait>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Trait) -> Option<Trait> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for TraitsBaseBuilder {
    type Entity = TraitsBase;
    const NAME: &'static str = "TraitsBaseBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TraitsBase::new_unchecked(inner.into())
    }
}
pub struct TraitsBaseIterator(TraitsBase, usize, usize);
impl ::core::iter::Iterator for TraitsBaseIterator {
    type Item = Trait;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for TraitsBaseIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for TraitsBase {
    type Item = Trait;
    type IntoIter = TraitsBaseIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        TraitsBaseIterator(self, 0, len)
    }
}
impl<'r> TraitsBaseReader<'r> {
    pub fn iter<'t>(&'t self) -> TraitsBaseReaderIterator<'t, 'r> {
        TraitsBaseReaderIterator(&self, 0, self.len())
    }
}
pub struct TraitsBaseReaderIterator<'t, 'r>(&'t TraitsBaseReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for TraitsBaseReaderIterator<'t, 'r> {
    type Item = TraitReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for TraitsBaseReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
